class FilterElement {
  constructor(textCssClass, textCallback, allValuesText, values, allValues, changeCallback) {
    this.textCssClass = textCssClass;
    this.textCallback = textCallback;
    this.allValuesText = allValuesText;
    this.values = values;
    this.changeCallback = changeCallback;
    this.allValues = allValues;
    this.jq = $('<span />').addClass('filterElement');
    this.textJq = $('<span />').
        addClass(this.textCssClass).
        addClass('filterText');
    this.jq.append(this.textJq).append($('<span>&#9660;</span>').addClass('arrow'));
  }
  
  // Called once per table load
  attachClickHandler(ancestorJq) {
    ancestorJq.on('click', '.' + this.textCssClass, this.textClicked.bind(this));
  }
  
  valuesToText() {
    if (this.values.length == 0) {
      return this.allValuesText;
    }
    let textParts = [];
    this.values.forEach(value => textParts.push(this.textCallback(value)));
    return textParts.join(', ');
  }
  
  updateTextJq() {
    let text;
    if (this.values.length == 0 || this.values.length === this.allValues.length) {
      text = this.allValuesText;
    } else {
      let textParts = [];
      this.values.forEach(value => textParts.push(this.textCallback(value)));
      text = textParts.join(', ');
    }
    this.textJq.text(text);
    this.jq.show();
  }
  
  textClicked(e) {
    let input = new MultiOptionInputMaker(this.allValues, this.textCallback).makeElement(this.values,
        (newValues) => {
          this.values = newValues;
          this.updateTextJq();
          this.changeCallback(newValues);
        },
        () => this.textJq.show());
    this.jq.parent().append(input);
    this.jq.hide();
  }
  
  appendTo(parentJq) {
    this.updateTextJq();
    parentJq.append(this.jq);
    this.attachClickHandler(parentJq);
  }
  
  getValues() {
    return this.values || this.allValues;
  }
}
