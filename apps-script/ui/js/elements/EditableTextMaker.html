class EditableTextMaker {
  constructor(sheetIdCallback, uuidCallback, textCssClass, emptyContent, textCallback, valueCallback, changeCallback, inputMaker) {
    this.sheetIdCallback = sheetIdCallback;
    this.uuidCallback = uuidCallback;
    this.textCssClass = textCssClass;
    this.emptyContent = emptyContent;
    this.textCallback = textCallback;
    this.valueCallback = valueCallback;
    this.changeCallback = changeCallback;
    this.inputMaker = inputMaker;
  }
  
  // Called once per table load
  attachClickHandler(ancestorJq) {
    ancestorJq.on('click', '.' + this.textCssClass, this.textClicked.bind(this));
  }
  
  updateTextJq(textJq, newText, newValue) {
    if (newText) {
      console.log('new text', newText);
      textJq.text(newText);
    } else {
      console.log('else');
      if (this.emptyContent instanceof jQuery) {
        console.log(this.emptyContent);
        textJq.append(this.emptyContent.clone());
      } else {
        console.log(this.emptyContent);
        textJq.text(this.emptyContent);
      }
    }
    textJq.attr('data-value', newValue || '');
  }
  
  textClicked(e) {
    var textJq = $(e.currentTarget);
    let input = this.inputMaker.makeElement(textJq.attr('data-value'),
        (newValue, newText) => {
          this.changeCallback(this.sheetIdCallback(textJq), this.uuidCallback(textJq), newValue);
          this.updateTextJq(textJq, newText, newValue);
          textJq.show();
        },
        () => textJq.show());
    textJq.parent().append(input);
    input.focus();
    textJq.hide();
  }
  
  makeElement(data) {
    let textJq = $('<span />').
        addClass(this.textCssClass).
        addClass('editableText');
    this.updateTextJq(textJq, this.textCallback(data), this.valueCallback(data));
    return textJq;
  }
}
